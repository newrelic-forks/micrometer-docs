= Micrometer New Relic
Jon Schneider <jschneider@pivotal.io>
:toc:
:sectnums:
:system: new-relic

New Relic is a powerful observability platform with Micrometer
https://github.com/newrelic/micrometer-registry-newrelic[support through its NewRelicRegistry implementation].
Micrometer metrics are converted into New Relic dimensional metrics, which can be
displayed in dashboards and used to create alerts.  The New Relic platform supports
full programmability in addition to custom queries with the NRQL language.

NOTE: New are discouraged from using the legacy `NewRelicMeterRegistry`.  Instead, use
the https://github.com/newrelic/micrometer-registry-newrelic[NewRelicRegistry implementation] (see below).

== Installing

See https://github.com/newrelic/micrometer-registry-newrelic#usage[the installation documentation].

== Configuring

To configure the New Relic registry, first create a configuration.  In the following example,
the apiKey is being sourced from an environment variable, but you may obtain it
from your environment or from a properties file or other location.  Your key can
be found in the "Manage Data" -> "API keys" section of https://insights.newrelic.com[New Relic Insights].

[source,java]
----

NewRelicRegistryConfig config = new NewRelicRegistryConfig() {

  @Override
  public String get(String key) {
    return null;
  }

  @Override
  public String apiKey() {
    return System.getenv("INSIGHTS_INSERT_KEY");
  }

  @Override
  public Duration step() {
    return Duration.ofSeconds(5);
  }

  @Override
  public String serviceName() {
    return "YourServiceNameHere";
  }
};
----

`NewRelicRegistryConfig` is an interface with a set of default methods that are
easily overloaded to provide application or environment specific configuration.
Alternatively, you can leverage your framework's configuration mechanism
to obtain the config values to be returned by your configuration instance.

After you have created the config, pass it to the NewRelicRegistry:

[source,java]
----
NewRelicRegistry newRelicRegistry =
    NewRelicRegistry.builder(config)
        .commonAttributes(
            new Attributes()
                .put("host.hostname", InetAddress.getLocalHost().getHostName())
                .put("your.custom", "item.here"))
        .build();
newRelicRegistry.start(new NamedThreadFactory("newrelic.micrometer.registry"));
return newRelicRegistry;
----


In Spring, this might look like xxxTODOxxx

in your If, in the implementation
of `get(String k)`, rather than returning `null`, you  instead bind it to a property source,
you can override the default configuration. For example, Micrometer's Spring Boot support binds properties
 prefixed with `management.metrics.export.newrelic` directly to the `NewRelicRegistryConfig`:

[source,yml]
----
management.metrics.export.newrelic:
    api-key: MY_INSIGHTS_API_KEY

    # The interval at which metrics are sent to New Relic. See Duration.parse for the expected format.
    # The default is 1 minute.
    step: 1m
----

== NR1 - The New Relic observability platform

https://docs.newrelic.com/docs/data-ingest-apis/get-data-new-relic/metric-api/introduction-metric-api#find-data
https://docs.newrelic.com/docs/using-new-relic/data/understand-data/query-new-relic-data
https://docs.newrelic.com/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql

This section serves as a quickstart to rendering useful representations in New Relic for metrics originating in Micrometer. See the https://docs.newrelic.com/docs/insights/nrql-new-relic-query-language/using-nrql/introduction-nrql[New Relic NRQL docs] for a far more complete reference of what is possible in New Relic.

=== Timers

At each publishing interval, the New Relic `Timer` produces a single event with the timer's name and several attributes:

1. `avg` - A mean latency for the publishing interval.
2. `count` - Throughput per second over the publishing interval.
3. `totalTime` - Total time per second over the publishing interval (used with `count`) to create aggregable means.

Additionally, if any percentiles or SLA buckets are defined on the timer, additional events are produced:

4. `${name}.percentiles` - Micrometer calculated percentiles for the publishing interval. One event is produced for each percentile, with a tag of `phi` in the range [0,1].
5. `${name}.histogram` - One event is produced for each SLA boundary with a tag of 'le', indicating that it represents a cumulative count of events less than or equal to SLA boundaries over the publishing interval.

To generate an aggregable view of latency in New Relic, divide `totalTime` by `count`:

[source,sql]
----
SELECT sum(totalTime)/sum(count) as 'Average Latency', max(max) as 'Max' FROM timer since 30 minutes ago TIMESERIES auto
----

.Timer latency.
image::img/new-relic-timer-latency.png[New Relic-rendered timer]

To generate a throughput chart:

[source,sql]
----
SELECT average(count) as 'Average Throughput' FROM timer since 30 minutes ago TIMESERIES auto
----

.Timer throughput.
image::img/new-relic-timer-throughput.png[New Relic-rendered timer throughput]

To generate a plot of client-side percentiles:

[source,sql]
----
SELECT latest(value) from timerPercentile FACET phi since 30 minutes ago TIMESERIES auto
----

.Timer Percentiles.
image::img/new-relic-timer-percentiles.png[New Relic-rendered percentiles]

Note how these percentiles are _not aggregable_. We've selected the `latest(value)` function to display this chart (i.e. it isn't correct to `average(value)` on a percentile value). The more dimensions you add to a timer, the less useful these values become.

Lastly, if you define SLA boundaries with the fluent builder for `Timer`, you can view throughput below certain SLA boundaries. In this example, we set SLA boundaries at 275 (yellow), 300 (red), and 500 (blue) milliseconds for a simulated `Timer` that is recording samples normally distributed around 250 ms. These counts represent the rate/second of samples less than or equal to each SLA boundary.

[source,sql]
----
SELECT sum(value) from timerHistogram FACET le since 30 minutes ago TIMESERIES auto
----

.Timer SLA boundaries.
image::img/new-relic-timer-sla.png[New Relic-rendered SLA boundaries]

Where the lines converge at various points it is evident that no sample exceeded the 275 ms SLA boundary.
